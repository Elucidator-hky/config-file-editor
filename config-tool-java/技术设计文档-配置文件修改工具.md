# 配置文件修改工具 - 技术设计文档

## 1. 核心理念与目标

本工具旨在解决开发和运维过程中，手动管理、修改散落在不同项目中、不同格式的配置文件所带来的繁琐、易错和低效的问题。

**核心目标**：
- **集中管理**：将不同环境（如开发、测试、生产）的配置项，通过"模板"进行集中化、语义化的管理。
- **一键切换**：允许用户通过选择一个模板，快速、准确地将一批配置值应用到所有相关的文件中。
- **DFM专用支持**：特别针对DFM场景，支持环境变量路径解析、数据库密码加密等特殊需求。

## 2. 核心工作流

### 阶段一：定义模板与配置项

此阶段是所有配置工作的起点，用户在此将一系列相关的配置抽象成一个逻辑集合。

1.  **创建模板**：用户首先创建一个"模板"，并为其赋予有意义的名称，例如"生产环境配置"或"XX项目测试环境"。
2.  **定义配置项**：在模板下，用户创建若干"配置项"。每个配置项代表一个需要管理的变量，例如"数据库主机地址"、"API密钥"或"日志级别"。用户可以为每个配置项添加描述和默认值。

### 阶段二：关联修改点

此阶段的目标是将抽象的"配置项"与磁盘上物理文件的具体修改位置精确地绑定起来。本工具采用一套统一的、基于交互式文本匹配的流程来完成此操作。

1.  **选择文件与输入搜索条件**: 用户选择一个目标文件，然后输入用于搜索的**前缀**（以及可选的**后缀**）。
2.  **触发搜索**: 用户点击【查找匹配项】按钮。
3.  **后台扫描与返回结果**: 系统逐行扫描目标文件，找出所有匹配的行，并将一个包含**行号**和**内容预览**的结果列表返回给前端。
4.  **交互式勾选**: 界面上弹出一个**带复选框的列表**，清晰地展示所有找到的匹配项。
    > 在 `nginx.conf` 中找到 4 个匹配项。请勾选希望由 **"Web服务器IP"** 控制的条目：
    >
    > `[ ]` **行 3**: `IP: 10.0.0.1`
    > `[ ]` **行 4**: `IP: 10.0.0.2`
    > `[ ]` **行 6**: `IP: 192.168.1.100`
    > `[ ]` **行 8**: `IP: 192.168.1.200`
5.  **确认选择与绑定**: 用户从列表中**勾选一个或多个**希望由当前配置项控制的行，然后点击【确认选择】。系统会将用户勾选的**每一行**都作为一个独立的、由"文件路径+行号"唯一锁定的修改点，与当前配置项进行绑定。

### 阶段三：执行修改

这是日常使用中最频繁的阶段，包含两个核心动作：

1.  **加载并填写**: 用户选择一个已配置好的模板。系统会加载该模板下的所有配置项，并自动从它们关联的修改点中读取"当前值"，显示在界面上。用户可以直接在旁边对应的"新值"输入框中填写目标值。

2.  **一键应用**: 用户填写完所有需要变更的值之后，点击"一键应用"按钮。系统会将所有已填写的"新值"，精确地写入到它们各自对应的目标位置。对于DFM场景，系统会自动处理数据库密码加密等特殊需求。

## 3. 关键设计策略

### 文件处理：通用文本匹配策略

为保证工具核心功能的开发效率和用户体验的绝对统一，当前版本采用单一的通用文本匹配策略来处理所有文件。

该策略不尝试理解任何特定文件的语法，而是通过一个**"前缀/后缀搜索 + 用户交互式勾选行号"**的流程，将定位修改的最终解释权和选择权完全交给用户。这种方式的核心优势在于：
- **高度灵活性**: 能适应任何格式的文本文件，甚至是语法不规范的文件。
- **操作一致性**: 用户只需学习一种操作模式，即可应对所有修改场景。
- **开发专注性**: 使我们能集中精力将这一核心功能做到极致。

### 数据存储：零依赖原则

工具的所有配置数据（如模板信息、关联关系等）都将以简单的 **JSON 文件**形式存储在程序目录下，实现了真正的**零依赖**和绿色便携。

## 4. 核心数据结构

为了支撑上述工作流，我们将定义以下核心数据结构。每个模板最终会作为一个独立的JSON文件存储。

### a. 模板 (`Template`)
这是最顶层的对象，代表一个完整的配置模板。

```json
{
  "id": "tpl-uuid-1234",
  "name": "生产环境配置",
  "description": "用于部署到线上服务器的各项配置。",
  "items": [
    // 包含多个配置项 (ConfigItem)
  ]
}
```

- **`id`**: 模板的唯一标识符。
- **`name`**: 用户定义的模板名称。
- **`description`**: 对模板的详细描述。
- **`items`**: 一个数组，包含了此模板下的所有`配置项`对象。

### b. 配置项 (`ConfigItem`)
代表一个需要统一管理的逻辑变量，如"数据库地址"。

```json
{
  "id": "item-uuid-5678",
  "name": "数据库主机地址",
  "description": "主数据库的IP地址或域名。",
  "defaultValue": "127.0.0.1",
  "targets": [
    // 包含多个目标点 (FileTarget)
  ]
}
```

- **`id`**: 配置项的唯一标识符。
- **`name`**: 用户定义的配置项名称。
- **`description`**: 对配置项的详细描述。
- **`defaultValue`**: (可选) 该配置项的一个默认值。
- **`targets`**: 一个数组，包含了此配置项关联的所有具体的`目标点`。一个配置项可以管理多个目标点，每个目标点都由一个独立的 `FileTarget` 对象来描述，因此是"一对多"的关系。

### c. 目标点 (`FileTarget`)
这是最关键的数据结构，它精确定义了文件系统中的一个具体修改位置。它是一个原子化的对象，代表一个不可再分的修改点。

```json
{
  "id": "target-uuid-abcd",
  "filePath": "C:\\project\\api\\config.ini",
  "lineNumber": 15,
  "prefix": "host = ",
  "suffix": ""
}
```

- **`id`**: 目标点的唯一标识符。
- **`filePath`**: 目标文件的绝对路径。
- **`lineNumber`**: 需要修改的**行号**。
- **`prefix`**: 该行中，目标值之前的**前缀**文本。
- **`suffix`**: (可选) 该行中，目标值之后的**后缀**文本。如果为空，则表示修改模式是"整行替换"（即用 `前缀` + `新值` 替换整行）。如果非空，则为"部分替换"（只替换 `前缀` 和 `后缀` 之间的内容）。

## 5. 界面设计与操作流程

我们将采用一个简洁、任务驱动的界面布局，将"日常使用"和"模板配置"清晰地分离开来。

### a. 主界面

这是用户启动应用后看到的第一个界面，专为**日常执行修改**而设计。

**布局**:
采用经典的两栏布局。
- **左侧 (模板列表区)**: 纵向排列所有已创建的模板。
- **右侧 (操作区)**: 显示当前选中模板的配置项，并执行修改。

```
+--------------------------------+-------------------------------------------+
|      模板列表 (左侧)           |             操作区 (右侧)                   |
|--------------------------------+-------------------------------------------|
|                                |                                           |
|  + 新建模板                      |  模板: [生产环境] [编辑模板]              |
|                                |                                           |
|  * 开发环境                      |  ---------------------------------------  |
|  * 测试环境                      |  配置项: 数据库地址                       |
|  * 生产环境 (选中)               |    当前值: 10.0.0.1                       |
|                                |    新值:   [ 192.168.1.100 ]              |
|                                |  ---------------------------------------  |
|                                |  配置项: 日志级别                         |
|                                |    当前值: info                           |
|                                |    新值:   [ debug         ]              |
|                                |                                           |
|                                |               +------------------------+  |
|                                |               |     一键应用           |  |
|                                |               +------------------------+  |
+--------------------------------+-------------------------------------------+
```

**操作流程**:
1.  用户在左侧列表中点击选择新建模板或者生成FDM模板。
2.  右侧操作区立即加载该模板下的所有配置项。
3.  系统自动读取每个配置项关联的所有目标点（文件位置）的当前值，并显示在"当前值"字段。
4.  用户在"新值"输入框中填写需要变更的值。对于DFM模板中的数据库密码，用户直接填写原始密码即可。
5.  全部填写完毕后，点击右下角的"一键应用"按钮，完成修改。
6.  如果需要修改模板本身的配置，可以点击模板名称旁边的【编辑模板】按钮，进入下一节描述的"模板编辑界面"。

### b. 模板编辑界面

这是一个独立的界面，用于**创建新模板**或**编辑现有模板**。当用户在主界面点击"新建模板"或"编辑模板"时进入此界面。

**布局**:
1.  **顶部**: 模板的"名称"和"描述"输入框。
2.  **中部 (配置项列表)**: 动态列表，展示当前模板包含的所有配置项。可以进行"添加配置项"、"删除配置项"的操作。
3.  **底部 (目标点列表)**: 当用户选中一个配置项时，此区域会显示该配置项已关联的所有"目标点"（即`FileTarget`对象）。

**核心操作 - 关联新的修改点**:
这是整个工具最核心的配置步骤，流程如下：
1.  用户选中一个配置项（如"数据库地址"），然后点击"添加目标点"按钮。
2.  弹出一个新的对话框或面板，要求用户：
    a. 点击【浏览】按钮选择一个文件。
    b. 输入用于搜索的`前缀`和可选的`后缀`。
3.  用户点击【查找匹配项】。
4.  系统执行搜索，并用一个**带复选框的列表**展示所有找到的匹配行。
5.  用户仔细检查列表，并**勾选**所有希望由"数据库地址"这个配置项管理的行。
6.  用户点击【确认选择】。
7.  系统为用户勾选的每一行都创建一个独立的`FileTarget`对象，并将它们全部保存到"数据库地址"这个配置项的`targets`列表中。
8.  在模板编辑界面的"目标点列表"中，会立即出现刚才新添加的所有目标点条目。
9.  用户完成所有模板修改后，点击【保存模板】按钮，返回主界面。



## 6. DFM模板特殊功能设计

### 6.1 DFM需求背景

DFM是工具的核心应用场景，具有以下特殊需求：
- **当前包路径**：配置文件路径依赖于当前包路径
- **环境变量路径**：配置文件路径依赖于环境变量（如`KMDFM_DIR_NX_64`）
- **数据库密码加密**：敏感信息需要使用特定算法加密
- **快速部署**：需要一键生成和应用配置到不同环境


### 6.2 半成品模板机制

为了解决DFM的特殊需求，设计了"半成品模板"机制：

**核心思路**：
- 预先制作一个包含常用配置项的模板骨架
- 使用占位符替代具体路径：`{{ENV:环境变量名}}`、`{{RELATIVE}}`
- 在运行时动态解析为实际路径，生成完整可用模板

**数据库密码特殊处理**：
- 对于需要加密的配置项，其目标点的`id`字段设置为`"passed"`
- 系统在写入文件时自动检测此标识，使用DFM加密算法处理

**动态目标点更新机制**：
- 半成品模板中的目标点不包含具体行号（因为不同环境可能不同）
- 生成DFM模板时，系统根据解析后的文件路径和前缀、后缀条件重新搜索匹配项
- 用搜索到的真实匹配项（包含准确行号）替换原来的占位符目标点
- 通常情况下一个文件只有一个匹配项，按1:1替换处理

### 6.3 DFM模板使用流程

**步骤1：制作半成品模板**
1. 创建一个普通的配置模板，包含所有需要的配置项
2. 在模板编辑界面，将所有目标点的文件路径替换为占位符格式：
   - 环境变量路径：`{{ENV:KMDFM_DIR_NX_64}}\config\app.ini`
   - 相对路径：`{{RELATIVE}}\config\database.conf`
3. 对于数据库密码等敏感配置项，将其目标点的`id`设置为`"passed"`
4. 保存为半成品模板文件：`data/skeletons/dfm-skeleton.json`

**步骤2：一键生成DFM模板**
1. 点击界面上的"生成DFM模板"按钮
2. 系统自动执行以下操作：
   - 读取环境变量配置
   - 加载半成品模板
   - 解析所有占位符为实际路径
   - **重新搜索匹配项**：对每个目标点，在解析后的实际文件中根据前缀、后缀条件搜索匹配项
   - **更新目标点**：用搜索到的真实匹配项（包含准确行号）替换原来的占位符目标点
   - 创建带时间戳的完整模板
   - 保存到模板列表中

**步骤3：状态检查**
1. 系统自动检查生成的模板中所有目标点的状态
2. 验证重新搜索后的目标点是否正确：
   - 文件路径是否存在
   - 是否成功找到匹配项
   - 行号是否准确定位
   - 前缀后缀是否能正确匹配
3. 只有当所有检查项都为"正确"状态时，才允许应用配置

**步骤4：应用配置**
1. 在生成的模板中填写各项配置值
2. 点击"应用配置"按钮
3. 系统自动处理：
   - 普通配置项直接写入文件
   - 带有`id="passed"`的配置项先进行DFM加密再写入
   - 返回应用结果

### 6.4 DFM加密机制

**触发条件**：
目标点的`id`字段为`"passed"`时，系统在写入文件时自动进行DFM加密

**加密处理**：
使用固定密钥进行加密，包含字符串倒置、XOR运算、格式化等步骤，确保数据库密码的安全性

### 6.5 DFM机制优势

**技术优势**：
- **环境适应性强**：半成品模板不依赖具体行号，适用于不同环境
- **自动精确定位**：动态搜索机制确保目标点位置的准确性
- **简化维护**：一个半成品模板适用于所有环境，无需为每个环境单独维护
- **零配置部署**：用户只需点击生成，无需手动设置文件路径和行号

**用户体验**：
- **操作简单**：一键生成完整可用的DFM配置模板
- **结果可靠**：状态检查确保所有目标点都能正确应用
- **自动加密**：数据库密码自动处理，用户无需关心加密细节

## 7. 远期升级目标

为了在未来进一步增强工具的**可靠性**和**专业性**，特别是在处理具有严格语法的结构化文件时，我们规划了以下升级路径：

### a. 引入专用解析器以增强结构化文件处理能力

在核心功能稳定后，逐步为 **JSON, YAML, XML, INI** 这四种主流配置文件格式引入各自的专用解析器。

**待实现方案**:
1.  **提供文件类型选择**: 在用户关联文件时，可以明确指定文件类型（如`JSON`, `XML`等）。
2.  **启用特定定位器**: 根据所选类型，系统将要求用户输入该格式专属的定位器，而非通用的前缀/后缀。
    - **JSON / YAML**: 使用**点号路径** (Dot Notation)，如 `database.host`。
    - **XML**: 使用 **XPath 表达式**，如 `/config/node/@value`。
    - **INI**: 使用 **`[节名]键名`** 组合，如 `[Database]Host`。
3.  **安全的读写操作**: 后端将使用专用库来解析文件，在内存中安全地修改值，然后再将完整的、语法正确的内容写回文件。

**升级优势**:
- **绝对的结构安全**: 从根本上杜绝因简单文本替换而破坏文件语法的风险。
- **强大的定位能力**: 可以轻松处理深层嵌套、数组等复杂数据结构。
- **保留数据类型**: 能正确区分和处理字符串、数字、布尔值等不同类型。

### b. 引入自动备份与回滚机制

**待实现方案**:
在执行"一键应用"时，为每一个即将被修改的文件创建一个带时间戳的副本（如 `config.json.bak.20231027143000`）。如果在批量修改过程中有任何一个文件写入失败，系统应能自动用备份文件恢复所有本次已修改过的文件，尽力保证环境的配置一致性。

**升级优势**:
- **操作安全**: 为用户的修改操作提供了一层"后悔药"，极大降低了误操作带来的风险。
- **事务完整性**: 保证了一次"一键应用"中的所有修改要么全部成功，要么全部回滚到初始状态，避免了部分文件修改成功而另一部分失败的中间状态。

